<?xml version="1.0" encoding="utf-8" ?>
<Imaginet>
	<Unit name="Imaginet.Units.Signal.SlidingWindow">
		<DisplayName>Sliding Window (data points)</DisplayName>
		<DisplayPath>/Signal Processing/Time Domain</DisplayPath>
		
		<Tags>
			<ContextPushData/>
		</Tags>

		<Description>
			<Header>Description</Header>
			Buffer streaming data into fixed-width overlapping windows using a circular buffer with configurable stride for real-time inference.
			
			This unit accumulates incoming data chunks into a sliding window of specified shape, producing output windows at intervals controlled by stride. Data is enqueued into a circular buffer and dequeued when enough samples have accumulated to advance by the stride amount. Supports optional timestamp tracking for temporal alignment.
			
			Window shape defines the total window size. Stride (in data points) controls overlap: smaller stride produces more overlapping windows, larger stride produces fewer windows with less overlap.

			<Header>Usage</Header>
			Use the Sliding Window unit as the final preprocessing step before model inference to create temporal context windows from streaming sensor data or time-series signals.
		</Description>

		<Parameters>
			<InputSocket
			  name="input"
			  text="Data Input"
			  description="Streaming data chunks to enqueue into the sliding window buffer." />

			<InputSocket
			  name="time_input"
			  timestamps="yes"
			  text="Time Input"
			  description="Optional timestamp data for temporal alignment. When provided, timestamps are tracked alongside data." />

			<ShapeOption
			  name="window_shape"
			  text="Window shape"
			  default="[128,3]"
			  description="Shape of the output window. Total size must be a multiple of input chunk size." />

			<Int32Option
			  name="stride"
			  min="1"
			  ui="textbox"
			  text="Stride"
			  default="3"
			  description="Number of data points to advance between windows. Must be a multiple of input chunk size and less than or equal to window size. Smaller values create more overlap."/>

			<Expression
				name="input_size"
				value="input.shape.flat"
				description="Total number of elements in each input chunk." />

			<Expression
				name="stride_count"
				value="stride / input_size"
				description="Number of input chunks to advance per stride." />

			<Expression
				name="window_count"
				value="window_shape.flat / input_size"
				description="Number of input chunks that fit in the window." />

			<Expression
				name="timestamp_count"
				value="time_input == null ? 0 : (time_input.shape.flat)"
				description="Number of timestamps in the input, or 0 if timestamps are not provided." />

			<OutputSocket
			  name="output"
			  type="input.type"
			  shape="window_shape"
			  rate="(input.rate * input_size) / Math.real(stride)"
			  rateIsApprox="true"
			  text="Output Window"
			  description="Windowed output produced when buffer has accumulated enough data to advance by stride. Has the specified window shape." />

			<OutputSocket
			  name="time_output"
			  type="System.Float32"
			  shape="System.Shape(2)"
			  timestamps="yes"
			  text="Time Output"
			  conditional="time_input != null"
			  description="Timestamp range for the window: [start_time, end_time]. Only produced when time_input is provided." />

			<Expression
				name="time_buffer_byte_size"
				value="time_input == null ? 0 : (window_count * 2 * time_input.type.size)"
				description="Size of timestamp buffer in bytes, or 0 if timestamps are not used." />

			<Expression
				name="input_byte_size"
				value="input.shape.flat * input.type.size"
				description="Size of each input chunk in bytes." />
			
			<Expression
				name="input_count"
				value="1"
				description="Number of input chunks processed per enqueue operation (always 1)." />

			<Expression
				name="data_buffer_byte_size"
				value="input_byte_size * window_count"
				description="Total size of the circular data buffer in bytes." />
			
			<Expression
				name="merge_time"
				value="false"
				description="Timestamp merging mode (always false for this unit)." />

			<Handle
			  name="handle"
			  size="208 + data_buffer_byte_size + time_buffer_byte_size"
			  description="Internal state handle containing circular buffer, pointers, and metadata."/>
		</Parameters>

		<Contracts>
			<Assert
			  test="stride &lt;= window_shape.flat"
			  error="Stride ({stride}) can't be bigger than window size ({window_shape.flat})" />
			<Assert
			  test="window_shape.flat % input_size == 0"
			  error="Window shape ({window_shape.flat}) must be a multiple of input size ({input_size})" />
			<Assert
			  test="stride % input_size == 0"
			  error="Stride ({stride}) must be a multiple of input size ({input_size})" />
		</Contracts>


		<Init>
			<!-- Init C implementation with timestamps -->
			<Implementation language="C" fragment="fixwin_time.h:fixwin_time_init" call="fixwin_time_init(handle, input_byte_size, window_count)">
				<Conditional value="time_input != null" />
			</Implementation>

			<!-- Init C implementation without timestamps -->
			<Implementation language="C" fragment="fixwin.h:fixwin_init" call="fixwin_init(handle, input_byte_size, window_count)">
				<Conditional value="time_input == null" />
			</Implementation>

		</Init>

		<SoftReset>
			<!-- Init C implementation with timestamps -->
			<Implementation language="C" fragment="fixwin_time.h:fixwin_time_init" call="fixwin_time_init(handle, input_byte_size, window_count)">
				<Conditional value="time_input != null" />
			</Implementation>

			<!-- Init C implementation without timestamps -->
			<Implementation language="C" fragment="fixwin.h:fixwin_init" call="fixwin_init(handle, input_byte_size, window_count)">
				<Conditional value="time_input == null" />
			</Implementation>

		</SoftReset>

		<Enqueue returnStatus="true">
			<!-- Enqueue C implementation with timestamps -->
			<Implementation language="C" fragment="fixwin_time.h:fixwin_time_enqueue" call="fixwin_time_enqueue(handle, input, time_input, timestamp_count)">
				<Conditional value="time_input != null" />
			</Implementation>

			<!-- Enqueue C implementation without timestamps -->
			<Implementation language="C" fragment="fixwin.h:fixwin_enqueue" call="fixwin_enqueue(handle, input)">
				<Conditional value="time_input == null" />
			</Implementation>

		</Enqueue>

		<Dequeue>
			<!-- Dequeue C implementation with timestamps -->
			<Implementation language="C" fragment="fixwin_time.h:fixwin_time_dequeue" call="fixwin_time_dequeue(handle, output, window_count, stride_count, time_output, merge_time)">
				<Conditional value="time_input != null" />
			</Implementation>

			<!-- Dequeue C implementation without timestamps -->
			<Implementation language="C" fragment="fixwin.h:fixwin_dequeue" call="fixwin_dequeue(handle, output, window_count, stride_count)">
				<Conditional value="time_input == null" />
			</Implementation>

		</Dequeue>

		<CanEnqueue>
			<Implementation language="C" fragment="fixwin_time.h:fixwin_time_can_enqueue" call="fixwin_time_can_enqueue(handle, input_count)">
				<Conditional value="time_input != null" />
			</Implementation>

			<Implementation language="C" fragment="fixwin.h:fixwin_can_enqueue" call="fixwin_can_enqueue(handle, input_count)">
				<Conditional value="time_input == null" />
			</Implementation>
		</CanEnqueue>

		<CanDequeue>
			<Implementation language="C" fragment="fixwin_time.h:fixwin_time_can_dequeue" call="fixwin_time_can_dequeue(handle, input_count)">
				<Conditional value="time_input != null" />
			</Implementation>

			<Implementation language="C" fragment="fixwin.h:fixwin_can_dequeue" call="fixwin_can_dequeue(handle, input_count)">
				<Conditional value="time_input == null" />
			</Implementation>
		</CanDequeue>

	</Unit>
</Imaginet>