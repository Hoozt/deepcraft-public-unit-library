<?xml version="1.0" encoding="utf-8" ?>
<Imaginet>
	<Unit name="Imaginet.Units.Math.Scale">
		<DisplayName>Scale</DisplayName>
		<DisplayPath>/Math/Element Wise</DisplayPath>

		<Description>
			<Header>Description</Header>
			Multiply each element by a constant scaling factor, computing (x × scale) for every element in the tensor.
			
			This unit performs element-wise multiplication with a fixed scalar value, scaling all elements uniformly. The scaling factor can be any real number. The tensor shape and dimensions are preserved.
			
			Currently supports float32 data type only.

			<Header>Usage</Header>
			Use the Scale unit when you need to amplify or attenuate signal values, normalize data, or apply a uniform gain factor across all elements.

			<Header>Python implementation</Header>
			<Inline fragment="scale.py:scale" language="Python" />
		</Description>

		<Parameters>
			<InputSocket name="input" text="Input" description="Input tensor to be scaled. Supports float32 data type only."/>
			<Expression name="count" value="input.shape.flat" description="Total number of elements in the input tensor (computed from flattened shape)." />
			<DoubleOption name="scale" text="Scale" default="1" description="The scaling factor to multiply each element by." />
			<OutputSocket name="output" type="input.type" shape="input.shape" text="Output" description="Output tensor containing scaled values. Has the same shape and data type as the input."/>
		</Parameters>
		
		<Contracts>
			<Assert 
				test="input.type == System.Float32"
				error="The input tensor ({input.type}) must have type: Float32" />
		</Contracts>

		<Implementations>
			<Implementation language="C" fragment="scale.h:scale_f32" call="scale_f32(input, count, scale, output)">
				<Conditional value="input.type == System.Float32" />
			</Implementation>			
			<Implementation language="Python" fragment="scale.py:scale" call="scale(input, scale, output)" />
		</Implementations>

	</Unit>

</Imaginet>