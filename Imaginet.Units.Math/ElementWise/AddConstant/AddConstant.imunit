<?xml version="1.0" encoding="utf-8" ?>
<Imaginet>
	<Unit name="Imaginet.Units.Math.AddConstant">
		<DisplayName>Add Constant</DisplayName>
		<DisplayPath>/Math/Element Wise</DisplayPath>

		<Description>
			<Header>Description</Header>
			Add a constant value to every element in the input tensor, computing (x + A) for each element.
			
			This unit performs element-wise addition of a user-defined constant A to all elements in the input tensor, preserving the shape and dimensions. The constant can be positive or negative, effectively allowing both addition and subtraction operations.
			
			The unit supports multiple data types (float32, int8, int16, int32) and fixed-point formats (Q7, Q15, Q31) with optional CMSIS optimized implementations for ARM-based embedded systems. For fixed-point types, the constant is automatically quantized to match the input format.

			<Header>Usage</Header>
			Use the Add Constant unit when you need to apply a uniform offset or bias to all values in a tensor.

			<Header>Python implementation</Header>
			<Inline fragment="addi.py:addi" language="Python" />
		</Description>

		<Parameters>
			<InputSocket name="input" description="Input tensor to which the constant will be added. Supports float32, int8, int16, int32, and fixed-point types (Q7, Q15, Q31)."/>
			<Expression name="count" value="input.shape.flat" description="Total number of elements in the input tensor (computed from flattened shape)." />
			
			<BoolOption name="global_use_cmsis" text="Use CMSIS" default="false" global="true" description="Enable CMSIS-optimized implementations for ARM Cortex processors. Improves performance on embedded systems."/>
			<Int32Option name="shift" value="0" description="Bit shift applied to the output for fixed-point arithmetic. Used to adjust the scale of the result."/>
			<DoubleOption name="A" text="Constant" description="The constant value to add to each element. Can be positive or negative."/>
			<Expression name="A_quantized" value="A.quantize(input.type, input.shift + shift)" description="The constant A quantized to match the input type and shift for fixed-point operations."/>
			<Expression name="A_round" value="A.round()" description="The constant A rounded to the nearest integer for integer type operations."/>
			<OutputSocket 
				name="output"
				type="input.type"
				shape="input.shape"
				text="Output" 
				description="Output tensor containing the result of adding the constant. Has the same shape and data type as the input." 
				shift="input.shift + shift" />
		</Parameters>

		<Implementations>
			<Implementation language="C" fragment="addi.h:addi_f32" call="addi_f32(input, count, A, output)">
				<Conditional value="!global_use_cmsis"/>
				<Conditional value="input.type == System.Float32" />
			</Implementation>

			<Implementation language="C" fragment="addi.h:addi_i8" call="addi_i8(input, count, A_round, output)">
				<!--<Conditional value="!global_use_cmsis"/>-->
				<Conditional value="input.type == System.Int8" />
			</Implementation>

			<Implementation language="C" fragment="addi.h:addi_i16" call="addi_i16(input, count, A_round, output)">
				<!--<Conditional value="!global_use_cmsis"/>-->
				<Conditional value="input.type == System.Int16" />
			</Implementation>

			<Implementation language="C" fragment="addi.h:addi_i32" call="addi_i32(input, count, A_round, output)">
				<!--<Conditional value="!global_use_cmsis"/>-->
				<Conditional value="input.type == System.Int32" />
			</Implementation>
						

			<Implementation language="C" fragment="addi_cmsis.h:addi_cmsis_f32" call="addi_cmsis_f32(input, count, A, output)">
				<Conditional value="global_use_cmsis"/>
				<Conditional value="input.type == System.Float32" />
			</Implementation>

			<Implementation language="C" fragment="addi_cmsis.h:addi_cmsis_q31" call="addi_cmsis_q31(input, count, A_quantized, output)">
				<Conditional value="global_use_cmsis"/>
				<Conditional value="shift == 0"/>
				<Conditional value="input.type == System.Q31" />
			</Implementation>

			<Implementation language="C" fragment="addi_cmsis.h:addi_cmsis_q15" call="addi_cmsis_q15(input, count, A_quantized, output)">
				<Conditional value="global_use_cmsis"/>
				<Conditional value="shift == 0"/>
				<Conditional value="input.type == System.Q15" />
			</Implementation>
			
			<Implementation language="C" fragment="addi_cmsis.h:addi_cmsis_q7" call="addi_cmsis_q7(input, count, A_quantized, output)">
				<Conditional value="global_use_cmsis"/>
				<Conditional value="shift == 0"/>
				<Conditional value="input.type == System.Q7" />
			</Implementation>

			<!-- Shifted -->

			<Implementation language="C" fragment="addi_cmsis.h:addi_shift_cmsis_q31" call="addi_shift_cmsis_q31(input, count, A_quantized, shift, output)">
				<Conditional value="global_use_cmsis"/>
				<Conditional value="shift != 0"/>
				<Conditional value="input.type == System.Q31" />
			</Implementation>

			<Implementation language="C" fragment="addi_cmsis.h:addi_shift_cmsis_q15" call="addi_shift_cmsis_q15(input, count, A_quantized, shift, output)">
				<Conditional value="global_use_cmsis"/>
				<Conditional value="shift != 0"/>
				<Conditional value="input.type == System.Q15" />
			</Implementation>

			<Implementation language="C" fragment="addi_cmsis.h:addi_shift_cmsis_q7" call="addi_shift_cmsis_q7(input, count, A_quantized, shift, output)">
				<Conditional value="global_use_cmsis"/>
				<Conditional value="shift != 0"/>
				<Conditional value="input.type == System.Q7" />
			</Implementation>

			<!-- Python -->
			
			<Implementation language="Python" fragment="addi.py:addi" call="addi(input, A, output)"/>
		</Implementations>

	</Unit>

</Imaginet>